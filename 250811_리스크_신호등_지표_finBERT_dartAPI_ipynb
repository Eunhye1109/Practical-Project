{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/Eunhye1109/Practical-Project/blob/EH/250811_%EB%A6%AC%EC%8A%A4%ED%81%AC_%EC%8B%A0%ED%98%B8%EB%93%B1_%EC%A7%80%ED%91%9C_finBERT_dartAPI_ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": true,
        "id": "9dQw0wrxvWcw"
      },
      "outputs": [],
      "source": [
        "# -*- coding: utf-8 -*-\n",
        "# RiskScanner Lite: 뉴스 기반 간이 리스크 스코어러 (짧고 안전하게)\n",
        "\n",
        "import os, requests, io, json\n",
        "from typing import List, Dict, Any, Tuple, Optional\n",
        "from datetime import datetime, timedelta, timezone\n",
        "from xml.etree import ElementTree as ET\n",
        "\n",
        "\n",
        "# ===== 설정 (환경변수 없으면 자동 폴백) =====\n",
        "NAVER_ID = os.getenv(\"NAVER_CLIENT_ID\", \"\")\n",
        "NAVER_SECRET = os.getenv(\"NAVER_CLIENT_SECRET\", \"\")\n",
        "USER_AGENT = \"RiskScannerLite/1.0\"\n",
        "HTTP_TIMEOUT = 10\n",
        "DEFAULT_DAYS = 30\n",
        "DEFAULT_MAX_ITEMS = 40\n",
        "MAX_TOTAL_SCORE = 6  # fund_flag(0~) + news_score(0,1,2)를 0~6 구간으로 정규화\n",
        "KST = timezone(timedelta(hours=9))\n",
        "try:\n",
        "    # 별도 파일에 키가 있다면(예: config_secret.py), 가장 우선 사용\n",
        "    import config_secret as _cfg\n",
        "    OPENAI_API_KEY = getattr(_cfg, \"OPENAI_API_KEY\", None) or os.getenv(\"OPENAI_API_KEY\", \"\")\n",
        "except Exception:\n",
        "    OPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\", \"\")\n",
        "\n",
        "try:\n",
        "    from openai import OpenAI\n",
        "except Exception:\n",
        "    OpenAI = None\n",
        "\n",
        "# ===== 안전 기본값 =====\n",
        "BACKUP_NEG_LEXICON = [\n",
        "    \"횡령\",\"배임\",\"분식\",\"적자\",\"자본잠식\",\"상장폐지\",\"소송\",\"경고\",\"리콜\",\"징계\",\"과징금\",\"벌금\",\n",
        "    \"파산\",\"부도\",\"유상증자\",\"감자\",\"유출\",\"해킹\",\"사고\",\"화재\",\"사망\",\"구속\",\"조사\",\"압수수색\",\n",
        "    \"거래정지\",\"연체\",\"채무불이행\",\"영업정지\",\"위반\",\"부정\",\"리스크\"\n",
        "]\n",
        "RED_KEYWORDS = [\n",
        "    \"횡령\",\"배임\",\"분식회계\",\"자본잠식\",\"상장폐지\",\"거래정지\",\"대규모 적자\",\"영업손실\",\"소송\",\"과징금\",\n",
        "    \"제재\",\"리콜\",\"압수수색\",\"유출\",\"해킹\",\"파산\",\"부도\",\"채무불이행\",\"구속\"\n",
        "]\n",
        "\n",
        "# ===== 유틸 =====\n",
        "def to_kst(dt: datetime) -> datetime:\n",
        "    return (dt.replace(tzinfo=timezone.utc) if dt.tzinfo is None else dt).astimezone(KST)\n",
        "\n",
        "def parse_rfc2822_date(s: str) -> Optional[datetime]:\n",
        "    try:\n",
        "        from email.utils import parsedate_to_datetime\n",
        "        return parsedate_to_datetime(s)\n",
        "    except Exception:\n",
        "        return None\n",
        "\n",
        "def clip_days(dt: datetime, days: int = DEFAULT_DAYS) -> bool:\n",
        "    return (to_kst(datetime.utcnow()) - to_kst(dt)) <= timedelta(days=days)\n",
        "\n",
        "def _strip_basic_tags(s: str) -> str:\n",
        "    return (s or \"\").replace(\"<b>\", \"\").replace(\"</b>\", \"\")\n",
        "\n",
        "# ===== 뉴스 수집(NAVER→Google RSS 폴백) =====\n",
        "def fetch_news_naver(query: str, display: int = DEFAULT_MAX_ITEMS) -> List[Dict[str, Any]]:\n",
        "    if not (NAVER_ID and NAVER_SECRET):\n",
        "        raise RuntimeError(\"NAVER 키 없음\")\n",
        "    headers = {\n",
        "        \"X-Naver-Client-Id\": NAVER_ID,\n",
        "        \"X-Naver-Client-Secret\": NAVER_SECRET,\n",
        "        \"User-Agent\": USER_AGENT\n",
        "    }\n",
        "    params = {\"query\": query, \"display\": min(100, display), \"start\": 1, \"sort\": \"date\"}\n",
        "    url = \"https://openapi.naver.com/v1/search/news.json\"\n",
        "    r = requests.get(url, headers=headers, params=params, timeout=HTTP_TIMEOUT)\n",
        "    r.raise_for_status()\n",
        "    data = r.json()\n",
        "    out = []\n",
        "    for it in data.get(\"items\", []):\n",
        "        dt = parse_rfc2822_date(it.get(\"pubDate\",\"\")) or to_kst(datetime.utcnow())\n",
        "        if not clip_days(dt):\n",
        "            continue\n",
        "        out.append({\n",
        "            \"title\": _strip_basic_tags(it.get(\"title\") or \"\"),\n",
        "            \"description\": _strip_basic_tags(it.get(\"description\") or \"\"),\n",
        "            \"link\": it.get(\"link\") or it.get(\"originallink\") or \"\",\n",
        "            \"date\": dt.isoformat(),\n",
        "        })\n",
        "        if len(out) >= DEFAULT_MAX_ITEMS:\n",
        "            break\n",
        "    return out\n",
        "\n",
        "def fetch_news_google_rss(query: str, max_items: int = DEFAULT_MAX_ITEMS) -> List[Dict[str, Any]]:\n",
        "    q = requests.utils.quote(query)\n",
        "    url = f\"https://news.google.com/rss/search?q={q}+when:{DEFAULT_DAYS}d&hl=ko&gl=KR&ceid=KR:ko\"\n",
        "    headers = {\"User-Agent\": USER_AGENT}\n",
        "    r = requests.get(url, headers=headers, timeout=HTTP_TIMEOUT)\n",
        "    r.raise_for_status()\n",
        "    root = ET.fromstring(r.text)\n",
        "    ch = root.find(\"channel\")\n",
        "    out = []\n",
        "    if ch is None: return out\n",
        "    for item in ch.findall(\"item\"):\n",
        "        pub = item.findtext(\"{http://purl.org/dc/elements/1.1/}date\") or item.findtext(\"pubDate\") or \"\"\n",
        "        dt = parse_rfc2822_date(pub) or to_kst(datetime.utcnow())\n",
        "        if not clip_days(dt):\n",
        "            continue\n",
        "        out.append({\n",
        "            \"title\": item.findtext(\"title\") or \"\",\n",
        "            \"description\": item.findtext(\"description\") or \"\",\n",
        "            \"link\": item.findtext(\"link\") or \"\",\n",
        "            \"date\": dt.isoformat(),\n",
        "        })\n",
        "        if len(out) >= max_items:\n",
        "            break\n",
        "    return out\n",
        "\n",
        "def fetch_news(query: str) -> List[Dict[str, Any]]:\n",
        "    try:\n",
        "        items = fetch_news_naver(query)\n",
        "        if items: return items\n",
        "    except Exception:\n",
        "        pass\n",
        "    try:\n",
        "        return fetch_news_google_rss(query)\n",
        "    except Exception:\n",
        "        return []\n",
        "\n",
        "\n",
        "# ===== 간이 감성(백업 사전 기반) =====\n",
        "def analyze_sentiment_backup(texts: List[str]) -> List[float]:\n",
        "    out = []\n",
        "    for t in texts:\n",
        "        low = (t or \"\").lower()\n",
        "        hits = sum(1 for w in BACKUP_NEG_LEXICON if w in low)\n",
        "        out.append(min(1.0, hits/3.0))  # 히트 많을수록 부정 확률↑\n",
        "    return out\n",
        "\n",
        "\n",
        "def smoothed_neg_ratio(neg_probs: List[float], thr: float=0.5, a: float=1.0, b: float=3.0) -> float:\n",
        "    if not neg_probs: return a / (a + b)\n",
        "    n = len(neg_probs); hits = sum(1 for p in neg_probs if p >= thr)\n",
        "    return (hits + a) / (n + a + b)\n",
        "\n",
        "def judge_label(neg_ratio: float) -> str:\n",
        "    return \"부정\" if neg_ratio >= 0.60 else (\"중립\" if neg_ratio >= 0.30 else \"긍정\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "9Vb_r2hYwtGC",
        "outputId": "c91b85d5-c1f0-4bb2-a1a8-c218713255ea"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "🔎 검색할 기업명 일부를 입력하세요:\n",
            "> 한화\n",
            "\n",
            "🟨 양호 - 노란색 (잠재적 위험도 36.7%)\n",
            "[리스크 조언] 치명적 이벤트(자본잠식/부도/파산/채무불이행), 완화될 여지 혹은 가능성 있음\n"
          ]
        }
      ],
      "source": [
        "from typing_extensions import Text\n",
        "# ===== 펀더멘털(간이) 추정: 뉴스에서 펀더멘털성 이벤트 추출 → flag/reasons =====\n",
        "def infer_fundamentals_from_news(texts: List[str]) -> Dict[str, Any]:\n",
        "    \"\"\"\n",
        "    외부 재무 API 없이도 뉴스에서 펀더멘털 성격의 이벤트를 감지해 가점.\n",
        "    대략적 기준 (최대 4점 권장):\n",
        "      - 치명적: '자본잠식','부도','파산','채무불이행' → +3\n",
        "      - 강함:   '감자','상장폐지','거래정지' → +2\n",
        "      - 중간:   '유상증자','대규모 적자','영업손실' → +1\n",
        "    컨텍스트가 불확실하면 가점을 한 단계 하향(보수화).\n",
        "    \"\"\"\n",
        "    text = \" \".join((t or \"\").lower() for t in texts)\n",
        "    reasons: List[str] = []\n",
        "\n",
        "    def hit(word: str) -> bool: return word in text\n",
        "    def any_hit(words: List[str]) -> bool: return any(hit(w) for w in words)\n",
        "\n",
        "    deadly = [\"자본잠식\",\"부도\",\"파산\",\"채무불이행\"]\n",
        "    strong = [\"감자\",\"상장폐지\",\"거래정지\"]\n",
        "    medium = [\"유상증자\",\"대규모 적자\",\"영업손실\"]\n",
        "\n",
        "    # 컨텍스트 동사(확정/공시/판결/개시/발생/완료/진행/임박 등)\n",
        "    context_confirm = [\"확정\",\"공시\",\"판결\",\"개시\",\"발생\",\"임박\",\"완료\",\"진행\"]\n",
        "    # 완화 표현(가능성/검토/우려/관측/전망/추정/해석/소식/설 등)\n",
        "    hedging_words = [\"가능성\",\"검토\",\"논의\",\"우려\",\"관측\",\"전망\",\"추정\",\"해석\",\"소식\",\"설\"]\n",
        "\n",
        "    raw = 0\n",
        "    if any_hit(deadly):\n",
        "        raw += 3; reasons.append(\"치명적 이벤트(자본잠식/부도/파산/채무불이행)\")\n",
        "    if any_hit(strong):\n",
        "        raw += 2; reasons.append(\"강한 이벤트(감자/상장폐지/거래정지)\")\n",
        "    if any_hit(medium):\n",
        "        raw += 1; reasons.append(\"중간 이벤트(유상증자/대규모 적자/영업손실)\")\n",
        "\n",
        "    # 컨텍스트/완화 보정\n",
        "    if raw > 0 and not any_hit(context_confirm):\n",
        "        raw -= 1\n",
        "        reasons.append(\"확정이라 단언할 수는 없음\")\n",
        "    if raw > 0 and any_hit(hedging_words):\n",
        "        raw -= 1\n",
        "        reasons.append(\"완화될 여지 혹은 가능성 있음\")\n",
        "\n",
        "    score = max(0, min(4, raw))\n",
        "    # 중복 제거\n",
        "    uniq = []\n",
        "    for r in reasons:\n",
        "        if r not in uniq:\n",
        "            uniq.append(r)\n",
        "    return {\"flag\": score, \"reasons\": uniq}\n",
        "\n",
        "# ===== 위험도 보정 (연속값 반영, 5% 고정 탈출) =====\n",
        "def calibrate_risk(total_score: int,\n",
        "                   max_total: int,\n",
        "                   news_count: int,\n",
        "                   neg_ratio: float,\n",
        "                   red_hits: int = 0) -> float:\n",
        "    \"\"\"\n",
        "    구성:\n",
        "    - 규칙 점수 기반: base = 100 * (total_score / max_total)\n",
        "    - 연속형 보정: news_cont = 15 * neg_ratio  (0~15%)\n",
        "    - 레드키워드 보정: red_boost = min(10, 1.5 * red_hits) (0~10%)\n",
        "    - 바닥치: 뉴스 있으면 5%, 없으면 2%\n",
        "    → 총합에서 바닥치만 보장(강제 5% 고정 없음)\n",
        "    \"\"\"\n",
        "    if max_total <= 0:\n",
        "        raw = 15.0 * max(0.0, min(1.0, neg_ratio)) + min(10.0, 1.5 * max(0, red_hits))\n",
        "    else:\n",
        "        base = 100.0 * (float(total_score) / float(max_total))\n",
        "        news_cont = 15.0 * max(0.0, min(1.0, neg_ratio))\n",
        "        red_boost = min(10.0, 1.5 * max(0, red_hits))\n",
        "        raw = base + news_cont + red_boost\n",
        "\n",
        "    floor = 5.0 if news_count > 0 else 2.0\n",
        "    return round(max(raw, floor), 1)\n",
        "\n",
        "# ===== GPT 한줄요약 =====\n",
        "GPT_SYSTEM_PROMPT = (\n",
        "    \"너는 한국 기업 리스크를 요약하는 애널리스트야. \"\n",
        "    \"입력 JSON(뉴스/레드키워드/펀더멘털/라벨/위험도/주요 제목)을 보고 1~2문장으로, \"\n",
        "    \"최대 120자 이내 한국어 존댓말로 친근하게, 중학생 수준의 쉬운 말로 요약하라. \"\n",
        "    \"요구사항: \"\n",
        "    \"1) 첫 문장에 레드키워드 개수와 핵심 부정 키워드를 괄호로 구체적으로 제시하라. \"\n",
        "    \"   예: '레드키워드 1건(자본잠식/부도/파산/채무불이행)…' \"\n",
        "    \"2) 가능하면 기사 제목에서 구체 사례 1개를 짧게 넣어라. 예: '아동 낙상 사고' \"\n",
        "    \"3) 둘째 문장에 완화/검토/가능성 등의 표현이 기사에 보이면 '하지만 … 가능성도 있네요!'처럼 \"\n",
        "    \"4) 출력은 오직 요약 문장만, 접두사/접미사/불릿/이모지는 쓰지 말 것.\"\n",
        ")\n",
        "\n",
        "\n",
        "def build_gpt_user_prompt(company: dict, news: dict, fundamental: dict, combined: dict, top_titles: List[str]) -> str:\n",
        "    payload = {\n",
        "        \"company\": {\"name\": company.get(\"corp_name\", \"\")},\n",
        "        \"news\": {\n",
        "            \"count\": news.get(\"news_count\", 0),\n",
        "            \"neg_ratio\": round(news.get(\"neg_ratio\", 0.0), 3),\n",
        "            \"label\": news.get(\"label_news\", \"\"),\n",
        "            \"red_hits\": news.get(\"red_hits\", 0),\n",
        "            \"top_titles\": top_titles[:3],\n",
        "        },\n",
        "        \"fundamental\": {\n",
        "            \"flag\": fundamental.get(\"flag\", 0),\n",
        "            \"reasons\": (fundamental.get(\"reasons\") or [])[:3],\n",
        "        },\n",
        "        \"combined\": {\n",
        "            \"final_label\": combined.get(\"final_label\", \"\"),\n",
        "            \"risk_pct\": combined.get(\"risk_pct\", 0.0),\n",
        "            \"total_score\": combined.get(\"total_score\", 0),\n",
        "        },\n",
        "        \"instruction\": \"부정 징후를 요인 단위로 묶어 핵심 1~2개만 나열하고 끝에 '관망' 또는 '주의'로 마무리.\"\n",
        "    }\n",
        "    return \"다음 JSON을 한 줄로 요약:\\n\\n\" + json.dumps(payload, ensure_ascii=False, indent=2)\n",
        "\n",
        "def gpt_one_liner(company, news, fundamental, combined, top_titles) -> str:\n",
        "    # 폴백(키 없음 또는 SDK 없음)\n",
        "    def _fallback():\n",
        "        bits = []\n",
        "        if news.get(\"red_hits\", 0) > 0:\n",
        "            bits.append(f\"레드키워드 {news['red_hits']}건\")\n",
        "        label = news.get(\"label_news\", \"\")\n",
        "        if label == \"부정\":\n",
        "            bits.append(\"부정 기사 다수\")\n",
        "        if fundamental.get(\"flag\", 0) >= 2:\n",
        "            bits.append(\"펀더멘털 경고\")\n",
        "        if not bits:\n",
        "            bits.append(\"특이 부정 신호 제한\")\n",
        "        tail = \"관망\" if (combined.get(\"final_label\") or label) != \"긍정\" else \"주의\"\n",
        "        return \"·\".join(bits[:2]) + f\", {tail}\"\n",
        "\n",
        "    if not (OPENAI_API_KEY and OpenAI):\n",
        "        return _fallback()\n",
        "\n",
        "    client = OpenAI(api_key=OPENAI_API_KEY)\n",
        "\n",
        "    try:\n",
        "        sys_prompt = GPT_SYSTEM_PROMPT\n",
        "        user_prompt = build_gpt_user_prompt(company, news, fundamental, combined, top_titles)\n",
        "        resp = client.chat.completions.create(\n",
        "            model=\"gpt-4o-mini\",\n",
        "            messages=[{\"role\": \"system\", \"content\": sys_prompt},\n",
        "                      {\"role\": \"user\", \"content\": user_prompt}],\n",
        "            max_tokens=80,\n",
        "            temperature=0.2,\n",
        "        )\n",
        "        txt = (resp.choices[0].message.content or \"\").strip()\n",
        "        return (txt.splitlines()[0] if txt else _fallback())[:120]\n",
        "    except Exception as e:\n",
        "        print(f\"⚠️ GPT 한줄요약 오류: {e}\")\n",
        "        return _fallback()\n",
        "\n",
        "#최종 라벨 함수 추가\n",
        "def decide_final_label(total_score: int) -> str:\n",
        "    \"\"\"\n",
        "    합산점수 기반 최종 라벨:\n",
        "    - 0~1: 안정\n",
        "    - 2~3: 양호\n",
        "    - 4~ : 주의\n",
        "    \"\"\"\n",
        "    if total_score >= 4:\n",
        "        return \"주의\"\n",
        "    if total_score >= 2:\n",
        "        return \"양호\"\n",
        "    return \"안정\"\n",
        "\n",
        "\n",
        "# ===== 평가 파이프라인 =====\n",
        "def evaluate_company(name: str) -> Dict[str, Any]:\n",
        "    # 1) 뉴스 수집\n",
        "    items = fetch_news(name)\n",
        "\n",
        "    # 2) 간이 감성/레드키워드\n",
        "    texts = [f\"{it.get('title','')} {it.get('description','')}\".strip() for it in items]\n",
        "    neg_probs = analyze_sentiment_backup(texts) if texts else []\n",
        "    neg_ratio = smoothed_neg_ratio(neg_probs)\n",
        "    label_news = judge_label(neg_ratio)\n",
        "    red_hits = 0\n",
        "    for t in texts:\n",
        "        low = (t or \"\").lower()\n",
        "        red_hits += sum(1 for w in RED_KEYWORDS if w.lower() in low)\n",
        "\n",
        "    # 3) 펀더멘털(간이) 추정 → flag/reasons\n",
        "    fundamental = infer_fundamentals_from_news(texts)\n",
        "    fund_flag = int(fundamental.get(\"flag\", 0) or 0)\n",
        "\n",
        "    # 🔼 레드키워드가 많으면 펀더멘털 가점(최대 1점) — 실무적 프록시\n",
        "    if red_hits >= 3:\n",
        "        fund_flag = min(4, fund_flag + 1)\n",
        "        reasons = fundamental.get(\"reasons\") or []\n",
        "        reasons.append(\"부정 키워드 다수(3건 이상)\")\n",
        "        fundamental[\"reasons\"] = reasons\n",
        "        fundamental[\"flag\"] = fund_flag\n",
        "\n",
        "    # 4) 종합 점수 및 위험도 보정 ← red_hits를 같이 반영\n",
        "    news_score = {\"긍정\": 0, \"중립\": 1, \"부정\": 2}[label_news]\n",
        "    total_score = fund_flag + news_score\n",
        "    risk_pct = calibrate_risk(total_score, MAX_TOTAL_SCORE, len(items), neg_ratio, red_hits=red_hits)\n",
        "\n",
        "    # 🔽 risk_pct 계산 후에 최종 라벨 결정\n",
        "    final_label = decide_final_label(total_score)\n",
        "\n",
        "    # 위험도 가드레일\n",
        "    if risk_pct >= 60.0:\n",
        "      final_label = \"부정\"\n",
        "    elif risk_pct >= 35.0 and final_label == \"긍정\":\n",
        "      final_label = \"중립\"\n",
        "\n",
        "# 5) 컴포넌트 dict들\n",
        "    company = {\"corp_name\": name, \"corp_code\": \"\", \"stock_code\": \"\"}\n",
        "    news = {\n",
        "        \"news_count\": len(items),\n",
        "        \"neg_ratio\": neg_ratio,\n",
        "        \"label_news\": label_news,\n",
        "        \"red_hits\": red_hits\n",
        "    }\n",
        "\n",
        "    # 6) GPT 한 줄 요약\n",
        "    top_titles = [it.get(\"title\", \"\") for it in items][:3]\n",
        "    combined = {\n",
        "        \"final_label\": final_label,    # ← risk_pct 가드레일 반영된 라벨\n",
        "        \"total_score\": total_score,    # ← 펀더멘털 flag + 뉴스 점수\n",
        "        \"risk_pct\": risk_pct,          # ← calibrate_risk 결과\n",
        "        \"one_liner\": gpt_one_liner(company, news, fundamental, {\n",
        "            \"final_label\": final_label,\n",
        "            \"total_score\": total_score,\n",
        "            \"risk_pct\": risk_pct,\n",
        "        }, top_titles)                 # ← 프롬프트 기반 GPT 한줄요약\n",
        "    }\n",
        "\n",
        "\n",
        "    # 7) 결과 반환\n",
        "    return {\n",
        "        \"company\": company,\n",
        "        \"news\": news,\n",
        "        \"fundamental\": fundamental,\n",
        "        \"combined\": combined,\n",
        "        \"items\": items\n",
        "    }\n",
        "\n",
        "# ===== CLI(노트북/서버 공통) =====\n",
        "def main():\n",
        "    print(\"🔎 검색할 기업명 일부를 입력하세요:\", flush=True)\n",
        "    try:\n",
        "        keyword = input(\"> \").strip()\n",
        "    except EOFError:\n",
        "        print(\"❌ 표준입력 없음\"); return\n",
        "    if not keyword:\n",
        "        print(\"❌ 기업명 키워드를 입력하세요.\"); return\n",
        "\n",
        "    result = evaluate_company(keyword)\n",
        "    corp = result[\"company\"]; news = result[\"news\"]; fundamental = result[\"fundamental\"]; combined = result[\"combined\"]\n",
        "\n",
        "    # print(f\"\\n📰 수집된 뉴스: {news['news_count']}건 (최근 {DEFAULT_DAYS}일)\")\n",
        "    # print(\"\\n===== 결과 =====\")\n",
        "    # print(f\"기업: {corp['corp_name']} (비상장, corp_code {corp['corp_code']})\")\n",
        "    # # print(f\"[뉴스] 부정비율(스무딩): {news['neg_ratio']*100:.1f}% | 레드키워드: {news['red_hits']}\")\n",
        "    # print(f\"[리스크 조언] flag: {fundamental.get('flag',0)} | 사유: {', '.join(fundamental.get('reasons',[])) or '없음'}\")\n",
        "    # # print(f\"[종합판정] 라벨: {combined['final_label']} | 총점: {combined['total_score']}/{MAX_TOTAL_SCORE} | 위험도(정규화): {combined['risk_pct']:.1f}%\")\n",
        "    # # print(f\"한줄요약: {combined.get('one_liner','')}\")\n",
        "\n",
        "    # 부정 확률 상위 기사 (최대 50개)\n",
        "    top_neg = sorted(\n",
        "        zip(analyze_sentiment_backup([f\"{i.get('title','')} {i.get('description','')}\".strip() for i in result[\"items\"]]),\n",
        "            result[\"items\"]),\n",
        "        key=lambda x: x[0], reverse=True\n",
        "    )[:50]\n",
        "\n",
        "    # if top_neg:\n",
        "    #     print(\"\\n⚠️ 부정 확률 높은 기사 Top 50\")\n",
        "    #     for p, it in top_neg:\n",
        "    #         dt = it.get(\"date\",\"\")[:19].replace(\"T\",\" \")\n",
        "    #         print(f\"- {p*100:5.1f}% | {dt} | {it.get('title','').strip()}\")\n",
        "\n",
        "    # 색상·리스크 관련 코멘트\n",
        "    mapping = {\"안정\": \"✅ 안정 - 초록색\", \"양호\": \"🟨 양호 - 노란색\", \"주의\": \"🟥 주의 - 빨간색\"}\n",
        "    print(\"\\n\" + mapping.get(combined[\"final_label\"], \"ℹ️ 알 수 없음 - 회색\"),\n",
        "          f\"(잠재적 위험도 {combined['risk_pct']:.1f}%)\")\n",
        "    print(f\"[리스크 조언] {', '.join(fundamental.get('reasons',[])) or '없음'}\")\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    main()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "fUCbNgQFJfhM"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNENEBZPWKAFJJ+F7F5cufR",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}